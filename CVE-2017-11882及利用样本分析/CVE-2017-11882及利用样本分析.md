## 0x01 漏洞描述

- **成因**：Windows的公式编辑器`EQNEDT32.EXE`读入包含MathType的OLE数据，在拷贝公式字体名称时没有对名称长度进行校验，使得攻击者可以通过刻意构造的数据内容覆盖栈上的函数返回地址，从而劫持程序流程。

- **影响版本**：Microsoft Office 2007 Service Pack 3, Microsoft Office 2010 Service Pack 2, Microsoft Office 2013 Service Pack 1, Microsoft Office 2016

- **POC**：[https://github.com/Ridter/CVE-2017-11882](https://github.com/Ridter/CVE-2017-11882)

## 0x02 漏洞分析

> 笔者复现及分析环境：Windows 7 Service Pack 1、Microsoft Office 2010、x32dbg、IDA 7.0

`EQUATION.exe`存在：

![图片1 Equation.exe](https://s1.ax1x.com/2020/03/16/8tZfr4.png)

设置注册表项`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\EQNEDT32.EXE`：

![图片2 regedit.exe](https://s1.ax1x.com/2020/03/16/8tZg2T.png)

`Debugger`键值为x32dbg路径。

生成POC：

![图片3 POC](https://s1.ax1x.com/2020/03/16/8tZcGV.png)

打开该文档，于`WinExec()`函数处设断：

![图片4 WinExec](https://s1.ax1x.com/2020/03/16/8tZ5Z9.png)

成功断下后，查看栈中返回地址：

![图片5 ReturnAdd](https://s1.ax1x.com/2020/03/16/8tZIaR.png)

继续向上查看栈，发现调用`WinExec()`的函数：

![图片6 Stack](https://s1.ax1x.com/2020/03/16/8tZ7Px.png)

通过IDA分析`sub_4115A7`功能：

![图片7 IDA](https://s1.ax1x.com/2020/03/16/8tZHG6.png)

跟进`sub_41160F`查看：

![图片8 sub41160F](https://s1.ax1x.com/2020/03/16/8tZOMD.png)

未校验长度，直接使用`strcpy()`函数，此处应该就是漏洞触发位置。进一步确定具体位置：

![图片9 strcpy](https://s1.ax1x.com/2020/03/16/8tZxZd.png)

于`0x411658`处设断，重新运行。第二次成功断下后，查看ESI寄存器指向内存内容：

![图片10 ESI](https://s1.ax1x.com/2020/03/16/8teSII.png)

此时ECX寄存器值为0xC，即复制48个字节到EDI寄存器指向内存，而`var_28`实际大小只有36个字节：

![图片11 EDI](https://s1.ax1x.com/2020/03/16/8te9it.png)

到达函数结束处：

![图片12 FunEnd](https://s1.ax1x.com/2020/03/16/8teCJP.png)

`leave`指令执行完毕后，栈顶`0x18F1D0`处值为`0x430C12`，即调用`WinExec()`。而传递参数正是`0x18F350`指向内存中的cmd指令：

![图片13 shellcode](https://s1.ax1x.com/2020/03/16/8tePRf.png)

成功弹出计算器：

![图片14 calc.exe](https://s1.ax1x.com/2020/03/16/8teiz8.png)

---

下面对使用到的POC进行简要分析。各变量含义由命名可知，RTF文档格式并非本文重点，如读者此前对RTF文档格式没有了解，建议先阅读文末**参考链接**中有关RTF文档格式的文章后再看POC源码。

![图片15 RTF](https://s1.ax1x.com/2020/03/16/8tekQS.png)

首先判断命令长度是否小于43，而43这个数字是因为：

![图片16 CmdLen](https://s1.ax1x.com/2020/03/16/8teAsg.png)

上图选中部分是插入命令处，具体偏移由POC中`COMMAND_OFFSET(0x949*2)`变量给出。

将命令插入到构造数据中之后，函数返回拼接好的OLE。下面将OLE嵌入到RTF文档中：

![图片17 OLE](https://s1.ax1x.com/2020/03/16/8teZZj.png)

## 0x03 摩诃草(APT-C-09)组织某样本分析

> MD5：0D38ADC0B048BAB3BD91861D42CD39DF

于`0x411658`处设断，在第二次断下时，各寄存器值如下：

![图片18 register](https://s1.ax1x.com/2020/03/16/8temon.png)

继续执行到函数结束处`leave`指令：

![图片19 leave](https://s1.ax1x.com/2020/03/16/8teKJ0.png)

`0x18F230`地址处值`0x430C47`即覆盖后的函数返回地址：

![图片20 FunReturn](https://s1.ax1x.com/2020/03/16/8teQzT.png)

而该地址处指令是`ret`，有些出乎意料。继续向下执行，来到`0x18F3B0`处，正是`0x18F234`地址处值：

![图片21 ret](https://s1.ax1x.com/2020/03/16/8te8L4.png)

这方才是构造者意欲执行的指令。经过蓝色方框中的一系列运算后，EBX指向是真正的Shellcode：

![图片22 shellcode](https://s1.ax1x.com/2020/03/16/8teYw9.png)

上述内容均可在OLE中查看(路径`\xl\embeddings`)：

![图片23 OLE](https://s1.ax1x.com/2020/03/16/8tetoR.png)

![图片24 OLE](https://s1.ax1x.com/2020/03/16/8teUF1.png)

将OLE`0x1000`—`0x1520`中数据复制到一bin文件后，通过IDA查看。`sub_247`功能如下：

![图片25 IDA](https://s1.ax1x.com/2020/03/16/8teaJx.png)

该函数接受的第二个参数即上文提到的EBX指向地址，于OLE中位置是`0x1040`，而`0x1040`+`0x558`处内容如下：

![图片26 PE](https://s1.ax1x.com/2020/03/16/8tedW6.png)

故该函数第一个功能是修正PE文件头。第二个功能流程如下：

![图片27 PEWrite](https://s1.ax1x.com/2020/03/16/8te0SK.png)

![图片28 PEWrite](https://s1.ax1x.com/2020/03/16/8teBQO.png)

![图片29 PEWrite](https://s1.ax1x.com/2020/03/16/8terOe.png)

![图片30 PEWrite](https://s1.ax1x.com/2020/03/16/8teyeH.png)

将`0x1040`+`0x558`后的PE文件数据写入到`%APPDATA%\MSBuild.exe`中。第三个功能流程如下：

![图片31 RegeditWrite](https://s1.ax1x.com/2020/04/03/GNCBwD.jpg)

![图片32 RegeditWrite](https://s1.ax1x.com/2020/04/03/GNC0eO.jpg)

![图片33 RegeditWrite](https://s1.ax1x.com/2020/04/03/GNCdOK.jpg)

将`%APPDATA%\MSBuild.exe`写入注册表run项键值`lollipop`中。

## 0x04 响尾蛇(SideWinder)组织某样本分析

将文档拖进WinHex查看：

![图片34 WinHex](https://s1.ax1x.com/2020/03/19/8sECTK.png)

可以看出该文档实质是一RTF格式文档。

用`rtfobj.py`分析如下：

![图片35 rtfobj](https://s1.ax1x.com/2020/03/19/8sAOW4.png)

Package后文会提到，先来看其CVE-2017-11882利用部分。

同样是第二次断下时：

![图片36 break](https://s1.ax1x.com/2020/03/19/8sE9w6.png)

其后的执行流程与上一样本相似：

![图片37 leave](https://s1.ax1x.com/2020/03/19/8sAvl9.png)

![图片38 ret](https://s1.ax1x.com/2020/03/19/8sAxyR.png)

经过绿色方框中的一系列运算后，调用`GlobalLock()`函数，传递参数如下：

![图片39 GlobalLock](https://s1.ax1x.com/2020/03/19/8sEiFO.png)

接下来跳转到`GlobalLock()`函数返回内存区域中：

![图片40 jmp](https://s1.ax1x.com/2020/03/19/8sEFYD.png)

经过两次`call`调用：

![图片41 call](https://s1.ax1x.com/2020/03/19/8sEkfe.png)

![图片42 call](https://s1.ax1x.com/2020/03/19/8sEESH.png)

修正内存中的字符串：

![图片43 EditString](https://s1.ax1x.com/2020/03/19/8sEVld.png)

接下来寻址`kernel32.dll`：

![图片44 kernel32](https://s1.ax1x.com/2020/03/19/8sEZ6A.png)

其所调用的函数功能如下：

![图片45 sub298](https://s1.ax1x.com/2020/03/19/8sEnmt.png)

两次`call`调用之后：

![图片46 call](https://s1.ax1x.com/2020/03/19/8sEKTf.png)

![图片47 call](https://s1.ax1x.com/2020/03/19/8sEltS.png)

其功能为返回某函数调用地址，此次是`LoadLibrayW()`：

![图片48 LoadLibrary](https://s1.ax1x.com/2020/03/19/8sEGlj.png)

![图片49 Loadlibrary](https://s1.ax1x.com/2020/03/19/8sEJ6s.png)

接下来，返回`GetProcAddress()`调用地址：

![图片50 GetProcAddress](https://s1.ax1x.com/2020/03/19/8sEYXn.png)

![图片51 GetProcAddress](https://s1.ax1x.com/2020/03/19/8sEa7V.png)

继续`call`调用：

![图片52 call](https://s1.ax1x.com/2020/03/19/8sEwkT.png)

其后流程如图所示：

![图片53 GetCommandLine](https://s1.ax1x.com/2020/03/19/8sEBhF.png)

![图片54 GetCommandLine](https://s1.ax1x.com/2020/03/19/8sErp4.png)

![图片55 call](https://s1.ax1x.com/2020/03/19/8sEs1J.png)

下面将字符串解密，并覆盖原CommandLine内容：

![图片56 DecryptStr](https://s1.ax1x.com/2020/03/19/8sYn2R.png)

![图片57 DecryptStr](https://s1.ax1x.com/2020/03/19/8sYjL6.png)

执行完结果如下：

![图片58 StrResult](https://s1.ax1x.com/2020/03/19/8sYqzR.png)

最后实际执行部分：

```
javascript:eval("sa=ActiveXObject;ab=new sa(\"Scripting.FileSystemObject\");
eval(ab.OpenTextFile(ab.GetSpecialFolder(2)+\"\\\\1.a\",1).ReadAll());windowclose()")
```

其后调用`RunHTMLApplication()`：

![图片59 RunHTMLApplicaton](https://s1.ax1x.com/2020/03/19/8sYOQ1.png)

![图片60 RunHTMLApplicaton](https://s1.ax1x.com/2020/03/19/8sYXsx.png)

![图片61 RunHTMLApplicaton](https://s1.ax1x.com/2020/04/03/GNPgN4.jpg)

![图片62 RunHTMLApplicaton](https://s1.ax1x.com/2020/04/03/GNP24J.jpg)

![图片63 RunHTMLApplicaton](https://s1.ax1x.com/2020/04/03/GNPWC9.jpg)

1.a就是之前提到RTF文档中的Package，其实质是一JS文件：

![图片64 JS](https://s1.ax1x.com/2020/04/03/GNPcEF.jpg)

![图片65 JS](https://s1.ax1x.com/2020/04/03/GNPyHU.jpg)

最后，其执行结果大体如下图所示：

![图片66 result](https://s1.ax1x.com/2020/04/03/GNPf3R.jpg)

## 0x05 蔓灵花(Bitter)组织某样本分析

通过远程模板注入的方式下载一RTF格式文档：

![图片67 downloadRTF](https://s1.ax1x.com/2020/03/21/8h8VnH.png)

拖进WinHex查看，可以确认其格式为RTF文档格式：

![图片68 Winhex](https://s1.ax1x.com/2020/03/21/8h8nAI.png)

添加文件扩展名后，打开该文档。同样是于于`0x411658`处第二次断下时：

![图片69 breakpoint](https://s1.ax1x.com/2020/03/21/8h8Aje.png)

![图片70 ret](https://s1.ax1x.com/2020/03/21/8h8kcD.png)

![图片71 shellcode](https://s1.ax1x.com/2020/03/21/8h8ZBd.png)

跳转之后经过绿色方框中一系列计算，接着跳转：

![图片72 jmp](https://s1.ax1x.com/2020/03/21/8h8K4P.png)

`fldpi`将π的值加载到FPU堆栈：

![图片73 fldpi](https://s1.ax1x.com/2020/03/21/8h8l38.png)

执行完后`fpu_instruction_pointer`指向`fldpi`指令，其后的`fnstenv`指令将`FpuSaveState`结构体保存到`esp-0xC`处：

![图片74 fnstenv](https://s1.ax1x.com/2020/03/21/8h81gS.png)

如此一来，`pop ebp`后EBP寄存器的值是`fpu_instruction_pointer`——`fldpi`指令位置：

![图片75 EBP](https://s1.ax1x.com/2020/03/21/8h8GuQ.png)

由EBP计算出需要解密的数据起始位置，EDX中存储的是数据长度(0x315)：

![图片76 Decrypt](https://s1.ax1x.com/2020/03/21/8h8JBj.png)

接着执行解密后的指令：

![图片77 Execute](https://s1.ax1x.com/2020/03/21/8h8NEn.png)

![图片78 Execute](https://s1.ax1x.com/2020/03/21/8h8wCV.png)

跳转后，执行相应指令，接下来`call`调用：

![图片79 call](https://s1.ax1x.com/2020/03/21/8h803T.png)

`sub_562B2F`功能是获取指定的系统函数调用地址，此次是`kernel32.VirtualAlloc()`：

![图片80 ReturnVirtualAddr](https://s1.ax1x.com/2020/03/21/8h8BgU.png)

![图片81 ReturnVirtualAddr](https://s1.ax1x.com/2020/03/21/8h8su4.png)

之后调用`VirtualAlloc()`申请内存空间：

![图片82 VirtualAlloc](https://s1.ax1x.com/2020/03/21/8h86b9.png)

向申请的内存空间中写入数据：

![图片83 WriteMem](https://s1.ax1x.com/2020/03/21/8hwGKP.png)

调用`sub_562B2F`获取`kernel32.Wow64DisableWow64FsRedirection()`调用地址：

![图片84 ReturnWow64DisableWow64FsRedirectionAddr](https://s1.ax1x.com/2020/03/21/8hwYb8.png)

`LoadLibrary(shell32)`：

![图片85 LoadLibrary(shell32)](https://s1.ax1x.com/2020/03/21/8hw3vt.png)

传递参数给`sub_562B2F`，获取`shell32.ShellExcute()`调用地址：

![图片86 ReturnShellExcuteAddr](https://s1.ax1x.com/2020/03/21/8hwa5Q.png)

![图片87 ReturnShellExcuteAddr](https://s1.ax1x.com/2020/03/21/8hw42R.png)

`LoadLibrary(urlmon)`：

![图片88 LoadLibrary(urlmon)](https://s1.ax1x.com/2020/03/21/8hw08s.png)

获取`urlmon.URLDownloadToFile()`调用地址：

![图片89 ReturnURLDownloadToFileAddr](https://s1.ax1x.com/2020/03/21/8hwoKx.png)
![图片90 ReturnURLDownloadToFileAddr](https://s1.ax1x.com/2020/03/21/8h0SMt.png)

调用`URLDownloadToFile()`，其传递参数如图：

![图片91 URLDownloadToFile](https://s1.ax1x.com/2020/03/21/8hwLIe.png)

![图片92 URLDownloadToFile](https://s1.ax1x.com/2020/03/21/8hwvRA.png)

读取文件：

![图片93 CreateFile](https://s1.ax1x.com/2020/03/21/8hwTr6.png)

![图片94 ReadFile](https://s1.ax1x.com/2020/03/21/8hwqaD.png)

由于没有获取到文件，计算出的EBX值错误：

![图片95 End](https://s1.ax1x.com/2020/03/21/8hwXPH.png)

故至此结束。

## 0x06 参考链接

- [Office恶意文件解析与混淆研究](https://zhuanlan.zhihu.com/p/31345299)

- [https://github.com/Ridter/CVE-2017-11882](https://github.com/Ridter/CVE-2017-11882)

- [Office文件格式基础知识](https://www.anquanke.com/post/id/175548)